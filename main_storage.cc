#include "common.h"
#include "main_storage.h"


MainStorage * MainStorage::instance_ = nullptr;
std::once_flag MainStorage::initInstanceFlag_;


MainStorage * MainStorage::instance() {
	std::call_once(initInstanceFlag_, []() {
        instance_ = new MainStorage();
    });
    return instance_;
}

void MainStorage::getData(float & x, float & y, float & z, float & roll, float & pitch, float & yaw) const {
	std::lock_guard<std::mutex> lk(lock_);
	x = x_;
	y = y_;
	z = z_;
	roll = roll_;
	pitch = pitch_;
	yaw = yaw_;
}

/*
In each setter, I implemented a check to ensure the data is within acceptable bounds. 
There is room for discussion here regarding how necessary this is, since the data is generated by a safe algorithm and won't come from outside sources. 
However, I believe this approach is justified because, in case of errors, it will make debugging easier.

How to report an error? One option was to throw an exception if an attempt was made to store invalid data. 
But I decided that it would be more appropriate to return a boolean variable, which can be checked if necessary - and I did exactly that in the "Task" class. 
This avoids the need to wrap the algorithm in try/catch blocks, and the program won't crash if an error occurs and the running algorithm isn't protected by try/catch.
*/

bool MainStorage::setX(float val) {
	std::lock_guard<std::mutex> lk(lock_);
	if (val >= MIN_COORD && val <= MAX_COORD) {
		x_ = val;	
		return true;
	}
	return false;
}

float MainStorage::getX() const {
	std::lock_guard<std::mutex> lk(lock_);
	return x_;
}

bool MainStorage::setY(float val) {
	std::lock_guard<std::mutex> lk(lock_);
	if (val >= MIN_COORD && val <= MAX_COORD) {
		y_ = val;	
		return true;
	}
	return false;
}

float MainStorage::getY() const {
	std::lock_guard<std::mutex> lk(lock_);
	return y_;
}

bool MainStorage::setZ(float val) {
	std::lock_guard<std::mutex> lk(lock_);
	if (val >= MIN_COORD && val <= MAX_COORD) {
		z_ = val;	
		return true;
	}
	return false;
}

float MainStorage::getZ() const {
	std::lock_guard<std::mutex> lk(lock_);
	return z_;
}

bool MainStorage::setRoll(float val) {
	std::lock_guard<std::mutex> lk(lock_);
	if (val >= MIN_ANGLE && val <= MAX_ANGLE) {
		roll_ = val;	
		return true;
	}
	return false;
}

float MainStorage::getRoll() const {
	std::lock_guard<std::mutex> lk(lock_);
	return roll_;
}

bool MainStorage::setPitch(float val) {
	std::lock_guard<std::mutex> lk(lock_);
	if (val >= MIN_ANGLE && val <= MAX_ANGLE) {
		pitch_ = val;	
		return true;
	}
	return false;
}

float MainStorage::getPitch() const {
	std::lock_guard<std::mutex> lk(lock_);
	return pitch_;
}

bool MainStorage::setYaw(float val) {
	std::lock_guard<std::mutex> lk(lock_);
	if (val >= MIN_ANGLE && val <= MAX_ANGLE) {
		yaw_ = val;	
		return true;
	}
	return false;
}

float MainStorage::getYaw() const {
	std::lock_guard<std::mutex> lk(lock_);
	return yaw_;
}